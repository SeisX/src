\chapter{Running Madagascar programs on the command line}

A simple way of using the collection of \texttt{Madagascar} programs
is running them on the command line using the Unix shell. According to
the Unix philosophy, each program tries to accomplish one task
only. It acts as a filter between standard input and standard output,
which take the form of data streams in RSF format. This allows
different programs to be combined in Unix pipes.

For example, the following pipe of commands, when run on the command
line, generates a synthetic sequence, stacks it, and prints out the output value:
\begin{verbatim}
sfmath n1=1000 output="8/(4*x1+1)/(4*x1+3)" | sfstack norm=n axis=1 | sfdisfil
\end{verbatim}

This chapter reviews some of the most commonly used
\texttt{Madagascar} programs and illustrates their usage with simple
examples. In the example below, \verb+bash$+ indicates the Unix shell prompt.

%\section{Unix shell overview}

Madagascar operates in a Unix shell environment, such as \texttt{bash}
(Bourne Again SHell) \cite[]{bash} or \texttt{csh} (C SHell)
\cite[]{tcsh}. It makes use of such command-line constructs as
standard input and standard output, pipes, and environmental
variables. To work effectively with Madagascar, it helps to know Unix shell and
basic Unix commands such as \texttt{cd}, \texttt{ls}, \texttt{cp},
etc. We assume that the reader is familiar with such environment.

\section{Main programs}

The source files for these programs can be found under
\href{https://github.com/ahay/src/blob/master/system/main}{\$RSFSRC/system/main}
directory in the Madagascar distribution. The "main" programs perform
general-purpose operations on RSF hypercubes regardless of the data
dimensionality or physical dimensions.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfadd}
}}

\texttt{sfadd} is useful for combining (adding, dividing, or
multiplying) several datasets. What if you want to subtract two
datasets? Easy. Use the \texttt{scale} parameter as follows:
\begin{verbatim}
bash$ sfadd data1.rsf data2.rsf scale=1,-1 > diff.rsf
\end{verbatim}
or
\begin{verbatim}
bash$ sfadd < data1.rsf data2.rsf scale=1,-1 > diff.rsf
\end{verbatim}
The same task can be accomplished with the more general \texttt{sfmath} program:
\begin{verbatim}
bash$ sfmath one=data1.rsf two=data2.rsf output='one-two' > diff.rsf
\end{verbatim}
or
\begin{verbatim}
bash$ sfmath < data1.rsf two=data2.rsf output='input-two' > diff.rsf
\end{verbatim}
In both cases, the size and shape of \texttt{data1.rsf} and
\texttt{data2.rsf} hypercubes should be the same, and a warning
message is printed out if the the axis sampling parameters (such as
\texttt{o1} or \texttt{d1}) in these files are different.


\noindent\doublebox{\parbox{\textwidth}{
\input{sfattr}
}}

\texttt{sfattr} is a useful diagnostic program. It reports certain
statistical values for an RSF dataset: RMS (root-mean-square)
amplitude, mean value, vector norm value, variance, standard deviation,
maximum and minimum values, number of nonzero samples, and the total
number of samples.

If we denote data values as $d_i$ for $i=0,1,2,\ldots,n$, then the RMS
value is $\sqrt{\frac{1}{n}\,\sum\limits_{i=0}^n d_i^2}$, the mean
value is $\frac{1}{n}\,\sum\limits_{i=0}^n d_i$, the $L_2$-norm value
is $\sqrt{\sum\limits_{i=0}^n d_i^2}$, the variance is
$\frac{1}{n-1}\,\left[\sum\limits_{i=0}^n d_i^2 - \frac{1}{n}\left(\sum\limits_{i=0}^n d_i\right)^2\right]$, and the standard
deviation is the square root of the variance. Using \texttt{sfattr}
is a quick way to see the distribution of data values and check it for
anomalies.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcat}
}}

\texttt{sfcat} and \texttt{sfmerge} concatenate two or more files
together along a particular axis. It is the same program, only
\texttt{sfcat} has the default \texttt{space=n} and \texttt{sfmerge}
has the default \texttt{space=y}.

Example of \texttt{sfcat}:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
bash$ sfcat one.rsf one.rsf axis=1 > two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=4           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        12 elements 48 bytes
\end{verbatim}

Example of \texttt{sfmerge}:
\begin{verbatim}
bash$ sfmerge one.rsf one.rsf axis=2 > two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=7           d2=0.1         o2=0          label2="Distance" unit2="km"
        14 elements 56 bytes
\end{verbatim}
In this case, an extra empty trace is inserted between the two merged files.

The axes that are not being merged are checked for consistency:
\begin{verbatim}
bash$ sfcat one.rsf two.rsf > three.rsf
sfcat: n2 mismatch: need 3
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcmplx}
}}

\texttt{sfcmplx} simply creates a complex dataset from its real and
imaginary parts. The reverse operation can be accomplished with
\texttt{sfreal} and \texttt{sfimag}.

Example of \texttt{sfcmplx}:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
bash$ sfcmplx one.rsf one.rsf > cmplx.rsf
bash$ sfin cmplx.rsf
cmplx.rsf:
    in="/tmp/cmplx.rsf@"
    esize=8 type=complex form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 48 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfconjgrad}
}}

\texttt{sfconjgrad} is a generic program for least-squares linear
inversion with the conjugate-gradient method. Suppose you have an
executable program \texttt{<prog>} that takes an RSF file from the
standard input and produces an RSF file in the standard output. It may
take any number of additional parameters but one of them must be
\texttt{adj=} that sets the forward (\texttt{adj=0}) or adjoint
(\texttt{adj=1}) operations.  The program \texttt{<prog>} is typically
an RSF program but it could be anything (a script, a multiprocessor
MPI program, etc.) as long as it implements a linear operator
$\mathbf{L}$ and its adjoint. There are no restrictions on the data
size or shape. You can easily test the adjointness with
\texttt{sfdottest}. The \texttt{sfconjgrad} program searches for a
vector $\mathbf{m}$ that minimizes the least-square misfit 
$\|\mathbf{d - L\,m}\|^2$ for the given input data vector $\mathbf{d}$.

Here is an example. The \texttt{sfhelicon}
program implements Claerbout's multidimensional helical filtering
\cite[]{GEO63-05-15321541}. It requires a filter to be specified in
addition to the input and output vectors. We create a helical 
2-D filter using the Unix \texttt{echo} command.
\begin{verbatim}
bash$ echo 1 19 20 n1=3 n=20,20 data_format=ascii_int in=lag.rsf > lag.rsf
bash$ echo 1 1 1 a0=-3 n1=3 data_format=ascii_float in=flt.rsf > flt.rsf
\end{verbatim}
Next, we create an example 2-D model and data vector with \texttt{sfspike}.
\begin{verbatim}
bash$ sfspike n1=50 n2=50 > vec.rsf
\end{verbatim}
The \texttt{sfdottest} program can perform the dot product test to
check that the adjoint mode works correctly.
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=5.28394
sfdottest: L'[d]*m=5.28394
\end{verbatim}
Your numbers may be different because \texttt{sfdottest} generates new
random input on each run.
Next, let us make some random data with \texttt{sfnoise}.
\begin{verbatim}
bash$ sfnoise seed=2005 rep=y < vec.rsf > dat.rsf
\end{verbatim}
and try to invert the filtering operation using \texttt{sfconjgrad}:
\begin{verbatim}
bash$ sfconjgrad sfhelicon filt=flt.rsf lag=lag.rsf \
mod=vec.rsf < dat.rsf > mod.rsf niter=10
sfconjgrad: iter 1 of 10
sfconjgrad: grad=3253.65
sfconjgrad: iter 2 of 10
sfconjgrad: grad=289.421
sfconjgrad: iter 3 of 10
sfconjgrad: grad=92.3481
sfconjgrad: iter 4 of 10
sfconjgrad: grad=36.9417
sfconjgrad: iter 5 of 10
sfconjgrad: grad=18.7228
sfconjgrad: iter 6 of 10
sfconjgrad: grad=11.1794
sfconjgrad: iter 7 of 10
sfconjgrad: grad=7.26941
sfconjgrad: iter 8 of 10
sfconjgrad: grad=5.15945
sfconjgrad: iter 9 of 10
sfconjgrad: grad=4.23055
sfconjgrad: iter 10 of 10
sfconjgrad: grad=3.57495
\end{verbatim}
The output shows that, in 10 iterations, the norm of the gradient vector decreases by almost 1000. 
We can check the residual misfit before
\begin{verbatim}
bash$ < dat.rsf sfattr want=norm
norm value = 49.7801
\end{verbatim}
and after
\begin{verbatim}
bash$ sfhelicon filt=flt.rsf lag=lag.rsf < mod.rsf | \
sfadd scale=1,-1 dat.rsf | sfattr want=norm
norm value = 5.73563
\end{verbatim}
In 10 iterations, the misfit decreased by an order of magnitude. The
result can be improved by running the program for more iterations.

An equivalent implementation for complex-valued inputs is \texttt{sfcconjgrad}. 

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcp}
}}

The \texttt{sfcp} and \texttt{sfmv} command imitate the Unix
\texttt{cp} and \texttt{mv} commands and serve for copying and moving
RSF files. Example:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
bash$ sfcp one.rsf two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcut}
}}

The \texttt{sfcut} command is related to \texttt{sfwindow} and has the same
set of arguments only instead of extracting the selected window, it fills it
with zeroes. The size of the input data is preserved. 

Examples:
\begin{verbatim}
bash$ sfspike n1=5 n2=5 > in.rsf
bash$ < in.rsf sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ < in.rsf sfcut n1=2 f1=1 n2=3 f2=2 | sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            0            0            1            1
  15:             1            0            0            1            1
  20:             1            0            0            1            1
bash$ < in.rsf sfcut j1=2 | sfdisfil
   0:             0            1            0            1            0
   5:             0            1            0            1            0
  10:             0            1            0            1            0
  15:             0            1            0            1            0
  20:             0            1            0            1            0
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfdd}
}}

The \texttt{sfdd} program is used to change either the form (\texttt{ascii},
\texttt{xdr}, \texttt{native}) or the type (\texttt{complex}, \texttt{float},
\texttt{int}, \texttt{char}) of the input dataset. 

In the example below, we create a plain text (ASCII) file with numbers and
then use \texttt{sfdd} to generate an RSF file in \texttt{xdr} form with
\texttt{complex} numbers. 
\begin{verbatim}
bash$ cat test.txt
1 2 3 4 5 6
bash$ echo n1=6 data_format=ascii_int in=test.txt > test.rsf
bash$ sfin test.rsf
test.rsf:
    in="test.txt"
    esize=0 type=int form=ascii
    n1=6           d1=?           o1=?
        6 elements
bash$ sfdd < test.rsf form=xdr type=complex > test2.rsf
bash$ sfin test2.rsf
test2.rsf:
    in="/tmp/test2.rsf@"
    esize=8 type=complex form=xdr
    n1=3           d1=?           o1=?
        3 elements 24 bytes
bash$ sfdisfil < test2.rsf
   0:          1,         2i         3,         4i         5,         6i
\end{verbatim}

To learn more about the RSF data format, consult Chapter 3.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfdisfil}
}}

The \texttt{sfdisfil} program simply dumps the data contents to the standard
output in a text form. It is used mostly for debugging purposes to quickly
examine RSF files. Here is an example:
\begin{verbatim}
bash$ sfmath o1=0 d1=2 n1=12 output=x1 > test.rsf
bash$ < test.rsf sfdisfil
   0:             0            2            4            6            8
   5:            10           12           14           16           18
  10:            20           22
\end{verbatim}
The output format is easily configurable.
\begin{verbatim}
bash$ < test.rsf sfdisfil col=6 number=n format="%5.1f"
  0.0  2.0  4.0  6.0  8.0 10.0
 12.0 14.0 16.0 18.0 20.0 22.0
\end{verbatim}
Along with \texttt{sfdd}, \texttt{sfdisfil} provides a simple way to convert
RSF data to an ASCII form.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfdottest}
}}

\texttt{sfdottest} is a generic dot-product test program for testing
linear operators. Suppose there is an executable program
\texttt{<prog>} that takes an RSF file from the standard input and
produces an RSF file in the standard output. It may take any number of
additional parameters but one of them must be \texttt{adj=} that sets
the forward (\texttt{adj=0}) or adjoint (\texttt{adj=1}) operations.
The program \texttt{<prog>} is typically an RSF program but it could
be anything (a script, a multiprocessor MPI program, etc.) as long as
it implements a linear operator $\mathbf{L}$ and its adjoint
$\mathbf{L}^T$. The \texttt{sfdottest} program is testing the equality
\begin{equation}
\label{eq:dptest}
\mathbf{d}^T\,\mathbf{L}\,\mathbf{m} = \mathbf{m}^T\,\mathbf{L}^T\,\mathbf{d}
\end{equation}
by using random vectors $\mathbf{m}$ and $\mathbf{d}$. You can invoke it with
\begin{verbatim}
bash$ sfdottest <prog> [optional aruments] mod=mod.rsf dat=dat.rsf
\end{verbatim}
where \texttt{mod.rsf} and \texttt{dat.rsf} are RSF files that
represent vectors from the model and data spaces. \texttt{sfdottest}
does not create any temporary files and does not have any restrictive
limitations on the size of the vectors.

Here is an example. We first setup a vector with 100 elements using
\texttt{sfspike} and then run \texttt{sfdottest} to test the
\texttt{sfcausint} program. \texttt{sfcausint} implements a linear
operator of causal integration and its adjoint, the anti-causal
integration.
\begin{verbatim}
bash$ sfspike n1=100 > vec.rsf
bash$ sfdottest sfcausint mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=1410.2
sfdottest: L'[d]*m=1410.2
bash$ sfdottest sfcausint mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=1165.87
sfdottest: L'[d]*m=1165.87
\end{verbatim}
The numbers are different on subsequent runs because of changing
seed in the random number generator.

Here is a somewhat more complicated example. The \texttt{sfhelicon}
program implements Claerbout's multidimensional helical filtering
\cite[]{GEO63-05-15321541}. It requires a filter to be specified in
addition to the input and output vectors. We create a helical 
2-D filter using the Unix \texttt{echo} command.
\begin{verbatim}
bash$ echo 1 19 20 n1=3 n=20,20 data_format=ascii_int in=lag.rsf > lag.rsf
bash$ echo 1 1 1 a0=-3 n1=3 data_format=ascii_float in=flt.rsf > flt.rsf
\end{verbatim}
Next, we create an example 2-D model and data vector with \texttt{sfspike}.
\begin{verbatim}
bash$ sfspike n1=50 n2=50 > vec.rsf
\end{verbatim}
Now the \texttt{sfdottest} program can perform the dot product test.
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
> mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=8.97375
sfdottest: L'[d]*m=8.97375
\end{verbatim}
Here is the same program tested in the inverse filtering mode:
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
> mod=vec.rsf dat=vec.rsf div=y
sfdottest:  L[m]*d=15.0222
sfdottest: L'[d]*m=15.0222
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfget}
}}

The \texttt{sfget} program extracts a parameter value from an RSF file. It is
useful mostly for scripting. Here is, for example, a quick calculation of the
maximum value on the first axis in an RSF dataset (the output of
\texttt{sfspike}) using the standard Unix \texttt{bc} calculator.
\begin{verbatim}
bash$ ( sfspike n1=100 | sfget n1 d1 o1; echo "o1+(n1-1)*d1" ) | bc
.396
\end{verbatim}
See also \texttt{sfput}.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfheadercut}
  }}

\texttt{sfheadercut} is close to \texttt{sfheaderwindow} but instead
of windowing the dataset, it fills the traces specified by the header
mask with zeroes. The size of the input data is preserved.

Here is an example of using \texttt{sfheaderwindow} for 
zeroing every other trace in the input file. First, let us create
an input file with ten traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=10 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7
  35:             8            8            8            8            8
  40:             9            9            9            9            9
  45:            10           10           10           10           10
\end{verbatim}
Next, we can create a mask with alternating ones and zeros using
\texttt{sfinterleave}.
\begin{verbatim}
bash$ sfspike n1=5 mag=1 | sfdd type=int > ones.rsf
bash$ sfspike n1=5 mag=0 | sfdd type=int > zeros.rsf
bash$ sfinterleave axis=1 ones.rsf zeros.rsf > mask.rsf
bash$ sfdisfil < mask.rsf
   0:    1    0    1    0    1    0    1    0    1    0
\end{verbatim}
Finally, \texttt{sfheadercut} zeros the input traces.
\begin{verbatim}
bash$ sfheadercut < input.rsf mask=mask.rsf > output.rsf
bash$ sfdisfil < output.rsf 
   0:             1            1            1            1            1
   5:             0            0            0            0            0
  10:             3            3            3            3            3
  15:             0            0            0            0            0
  20:             5            5            5            5            5
  25:             0            0            0            0            0
  30:             7            7            7            7            7
  35:             0            0            0            0            0
  40:             9            9            9            9            9
  45:             0            0            0            0            0
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheadersort}
}}

\texttt{sfheadersort} is used to sort traces in the input file
according to trace header information. 

Here is an example of using
\texttt{sfheadersort} for randomly shuffling traces in the input
file. First, let us create an input file with seven traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=7 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7 
\end{verbatim}
Next, we can create a random file with seven header values using
\texttt{sfnoise}.
\begin{verbatim}
bash$ sfspike n1=7 | sfnoise rep=y type=n > random.rsf
bash$ < random.rsf sfdisfil
   0:       0.05256      -0.2879       0.1487       0.4097       0.1548
   5:        0.4501       0.2836
\end{verbatim}
If you reproduce this example, your numbers will most likely be different,
because, in the absence of \texttt{seed=} parameter, \texttt{sfnoise}
uses a random seed value to generate pseudo-random numbers. Finally, we
apply \texttt{sfheadersort} to shuffle the input traces.
\begin{verbatim}
bash$ < input.rsf sfheadersort head=random.rsf > output.rsf
bash$ < output.rsf sfdisfil
   0:             2            2            2            2            2
   5:             1            1            1            1            1
  10:             3            3            3            3            3
  15:             5            5            5            5            5
  20:             7            7            7            7            7
  25:             4            4            4            4            4
  30:             6            6            6            6            6
\end{verbatim}
As expected, the order of traces in the output file corresponds to the
order of values in the header. Thanks to the separation between
headers and data, the operation of \texttt{sfheadersort} is optimally
efficient. It first sorts the headers and only then accesses the data,
reading each data trace only once.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheaderwindow}
}}

\texttt{sfheaderwindow} is used to window traces in the input file
according to trace header information. 

Here is an example of using \texttt{sfheaderwindow} for randomly
selecting part of the traces in the input file. First, let us create
an input file with ten traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=10 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7
  35:             8            8            8            8            8
  40:             9            9            9            9            9
  45:            10           10           10           10           10
\end{verbatim}
Next, we can create a random file with ten header values using
\texttt{sfnoise}.
\begin{verbatim}
bash$ sfspike n1=10 | sfnoise rep=y type=n > random.rsf
bash$ < random.rsf sfdisfil
   0:     -0.005768      0.02258     -0.04331      -0.4129      -0.3909
   5:      -0.03582       0.4595      -0.3326        0.498      -0.3517
\end{verbatim}
If you reproduce this example, your numbers will most likely be different,
because, in the absence of \texttt{seed=} parameter, \texttt{sfnoise}
uses a random seed value to generate pseudo-random numbers. Finally,
we apply \texttt{sfheaderwindow} to window the input traces selecting
only those for which the header is greater than zero.
\begin{verbatim}
bash$ < random.rsf sfmask min=0 > mask.rsf
bash$ < mask.rsf sfdisfil
   0:    0    1    0    0    0    0    1    0    1    0
bash$ < input.rsf sfheaderwindow mask=mask.rsf > output.rsf
bash$ < output.rsf sfdisfil
   0:             2            2            2            2            2
   5:             7            7            7            7            7
  10:             9            9            9            9            9
\end{verbatim}
In this case, only three traces are selected for the output. Thanks to
the separation between headers and data, the operation of
\texttt{sfheaderwindow} is optimally efficient. 

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfin}
  }}

\texttt{sfin} is one of the most useful programs for operating with
RSF files. It produces quick information on the file hypercube
dimensions and checks the consistency of the associated data file.

Here is an example. Let us create an RSF file and examine it with \texttt{sfin}.
\begin{verbatim}
bash$ sfspike n1=100 n2=20 > spike.rsf
bash$ sfin spike.rsf
spike.rsf:
    in="/tmp/spike.rsf@"
    esize=4 type=float form=native
    n1=100         d1=0.004       o1=0          label1="Time" unit1="s"
    n2=20          d2=0.1         o2=0          label2="Distance" unit2="km"
        2000 elements 8000 bytes
\end{verbatim}
\texttt{sfin} reports the following information:
\begin{itemize}
\item location of the data file (\texttt{/tmp/spike.rsf\@})
\item element size (4 bytes)
\item element type (floating point)
\item element form (native)
\item hypercube dimensions (100 by 20)
\item axes scale (0.004 and 0.1)
\item axes origin (0 and 0)
\item axes labels
\item axes units
\item total number of elements
\item total number of bytes in the data file
\end{itemize}

Suppose that the file got corrupted by a buggy program and reports
incorrect dimensions. The \texttt{sfin} program should be able to
catch the discrepancy.
\begin{verbatim}
bash$ echo n2=100 >> spike.rsf
bash$ sfin spike.rsf > /dev/null
sfin:           Actually 8000 bytes, 20% of expected.
\end{verbatim}

\texttt{sfin} also checks the first records in the file for zeros. 
\begin{verbatim}
bash$ sfspike n1=100 n2=100 k2=99 > spike2.rsf
bash$ sfin spike2.rsf >/dev/null
sfin: The first 32768 bytes are all zeros
\end{verbatim}
The number of bytes to check is adjustable
\begin{verbatim}
bash$ sfin spike2.rsf check=0.01 >/dev/null
sfin: The first 16384 bytes are all zeros
\end{verbatim}

You can also output only the location of the data file. This is
sometimes handy in scripts.
\begin{verbatim}
bash$ sfin spike.rsf spike2.rsf info=n
/tmp/spike.rsf@ /tmp/spike2.rsf@
\end{verbatim}
An alternative is to use \texttt{sfget}, as follows:
\begin{verbatim}
bash$ sfget parform=n in < spike.rsf
/tmp/spike.rsf@
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfinterleave}
  }}

\texttt{sfinterleave} combines two or more datasets by interleaving them on one
of the axes. Here is a quick example:
\begin{verbatim}
bash$ sfspike n1=5 n2=5 > one.rsf
bash$ sfdisfil < one.rsf
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ sfscale < one.rsf dscale=2 > two.rsf
bash$ sfdisfil < two.rsf
   0:             2            2            2            2            2
   5:             2            2            2            2            2
  10:             2            2            2            2            2
  15:             2            2            2            2            2
  20:             2            2            2            2            2
bash$ sfinterleave one.rsf two.rsf axis=1 | sfdisfil
   0:             1            2            1            2            1
   5:             2            1            2            1            2
  10:             1            2            1            2            1
  15:             2            1            2            1            2
  20:             1            2            1            2            1
  25:             2            1            2            1            2
  30:             1            2            1            2            1
  35:             2            1            2            1            2
  40:             1            2            1            2            1
  45:             2            1            2            1            2
bash$ sfinterleave < one.rsf two.rsf axis=2 | sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             1            1            1            1            1
  15:             2            2            2            2            2
  20:             1            1            1            1            1
  25:             2            2            2            2            2
  30:             1            1            1            1            1
  35:             2            2            2            2            2
  40:             1            1            1            1            1
  45:             2            2            2            2            2
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfmask}
  }}

\texttt{sfmask} creates an integer output of ones and zeros comparing
the values of the input data to specified \texttt{min=} and
\texttt{max=} parameters. It is useful for \texttt{sfheaderwindow} and
in many other applications. Here is a quick example:
\begin{verbatim}
bash$ sfmath n1=10 output="sin(x1)" > sin.rsf
bash$ < sin.rsf sfdisfil
   0:             0       0.8415       0.9093       0.1411      -0.7568
   5:       -0.9589      -0.2794        0.657       0.9894       0.4121
bash$ < sin.rsf sfmask min=-0.5 max=0.5 | sfdisfil
   0:    1    0    0    1    0    0    1    0    0    1
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfmath}
  }}

\inputdir{sfmath}

\texttt{sfmath} is a versatile program for mathematical operations
with RSF files. It can operate with several input files, all of the
same dimensions and data type. The data type can be real (floating
point) or complex. Here is an example that demonstrates several
features of \texttt{sfmath}.
\begin{verbatim}
bash$ sfmath n1=629 d1=0.01 o1=0 n2=40 d2=1 o2=5 \
output="x2*(8+sin(6*x1+x2/10))" > rad.rsf
bash$ < rad.rsf sfrtoc | sfmath output="input*exp(I*x1)" > rose.rsf
bash$ < rose.rsf sfgraph title=Rose screenratio=1 wantaxis=n | sfpen
\end{verbatim}

The first line creates a 2-D dataset that consists of 40 traces 629
samples each. The values of the data are computed with the formula
\verb#"x2*(8+sin(6*x1+x2/10))"#, where \texttt{x1} refers to the
coordinate on the first axis, and \texttt{x2} is the coordinate of the
second axis. In the second line, we convert the data from real to
complex using \texttt{sfrtoc} and produce a complex dataset using
formula \verb#"input*exp(I*x1)"#, where \texttt{input} refers to the
input file. Finally, we plot the complex data as a collection of
parametric curves using \texttt{sfgraph} and display the result using
\texttt{sfpen}.  The plot appearing on your screen should look similar
to Figure~\ref{fig:rose}.

\plot{rose}{width=0.6\textwidth}{This figure was created with \texttt{sfmath}.}

One possible alternative to the second line above is
\begin{verbatim}
bash$ < rad.rsf sfmath output=x1 > ang.rsf
bash$ sfmath r=rad.rsf a=ang.rsf output="r*cos(a)" > cos.rsf
bash$ sfmath r=rad.rsf a=ang.rsf output="r*sin(a)" > sin.rsf
bash$ sfcmplx cos.rsf sin.rsf > rose.rsf
\end{verbatim}
Here we refer to input files by names (\texttt{r} and \texttt{a}) and combine the names in a formula.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfpad}
  }}

\texttt{sfpad} increases the dimensions of the input dataset by padding
the data with zeroes. Here are some simple examples.

\begin{verbatim}
bash$ sfspike n1=5 n2=3 > one.rsf
bash$ sfdisfil < one.rsf
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
bash$ < one.rsf sfpad n2=5 | sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             0            0            0            0            0
  20:             0            0            0            0            0
bash$ < one.rsf sfpad beg2=2 | sfdisfil
   0:             0            0            0            0            0
   5:             0            0            0            0            0
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ < one.rsf sfpad beg2=1 end2=1 | sfdisfil
   0:             0            0            0            0            0
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             0            0            0            0            0
bash$ < one.rsf sfwindow n1=3 | sfpad n1=5 n2=5 beg1=1 beg2=1 | sfdisfil
   0:             0            0            0            0            0
   5:             0            1            1            1            0
  10:             0            1            1            1            0
  15:             0            1            1            1            0
  20:             0            0            0            0            0
\end{verbatim}
You can use \texttt{sfcat} to pad data with values other than zeroes.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfput}
  }}

\texttt{sfput} is a very simple program. It simply appends parameters
from the command line to the output RSF file. One can achieve similar
results with editing the file by hand or with standard Unix utilities like
\texttt{sed} and \texttt{echo}. \texttt{sfput} is sometimes more
convenient because it handles input/output operations similarly to
other Madagascar programs.

\begin{verbatim}
bash$ sfspike n1=10 > spike.rsf
bash$ sfin spike.rsf
spike.rsf:
    in="/tmp/spike.rsf@"
    esize=4 type=float form=native
    n1=10          d1=0.004       o1=0          label1="Time" unit1="s"
        10 elements 40 bytes
bash$ sfput < spike.rsf d1=25 label1=Depth unit1=m > spike2.rsf
bash$ sfin spike2.rsf
spike2.rsf:
    in="/tmp/spike2.rsf@"
    esize=4 type=float form=native
    n1=10          d1=25          o1=0          label1="Depth" unit1="m"
        10 elements 40 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfreal}
  }}

\texttt{sfreal} extracts the real part of a complex type dataset. The
imaginary part can be extracted with \texttt{sfimag}, an the real
and imaginary part can be combined together with \texttt{sfcmplx}.


Here is a simple example. Let us first create a complex dataset 
with \texttt{sfmath}
\begin{verbatim}
bash$ sfmath n1=10 type=complex output="(2+I)*x1" > cmplx.rsf
bash$ fdisfil < cmplx.rsf
   0:          0,         0i         2,         1i         4,         2i
   3:          6,         3i         8,         4i        10,         5i
   6:         12,         6i        14,         7i        16,         8i
   9:         18,         9i
\end{verbatim}
Extracting the real part with \texttt{sfreal}:
\begin{verbatim}
bash$ sfreal < cmplx.rsf | sfdisfil
   0:             0            2            4            6            8
   5:            10           12           14           16           18
\end{verbatim}
Extracting the imaginary part with \texttt{sfimag}:
\begin{verbatim}
bash$ sfimag < cmplx.rsf | sfdisfil
   0:             0            1            2            3            4
   5:             5            6            7            8            9
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfreverse}
  }}

Here is an example of using \texttt{sfreverse}. First, let us create a
2-D dataset.
\begin{verbatim}
bash$ sfmath n1=5 d1=1 n2=3 d2=1 output=x1+x2 > test.rsf
bash$ < test.rsf sfdisfil
   0:             0            1            2            3            4
   5:             1            2            3            4            5
  10:             2            3            4            5            6
\end{verbatim}
Reversing the first axis:
\begin{verbatim}
bash$ < test.rsf sfreverse which=1 | sfdisfil
   0:             4            3            2            1            0
   5:             5            4            3            2            1
  10:             6            5            4            3            2
\end{verbatim}
Reversing the second axis:
\begin{verbatim}
bash$ < test.rsf sfreverse which=2 | sfdisfil
   0:             2            3            4            5            6
   5:             1            2            3            4            5
  10:             0            1            2            3            4
\end{verbatim}
Reversing both the first and the second axis:
\begin{verbatim}
bash$ < test.rsf sfreverse which=3 | sfdisfil
   0:             2            3            4            5            6
   5:             1            2            3            4            5
  10:             0            1            2            3            4
\end{verbatim}
As you can see, the \texttt{which=} parameter controls the axes that are
being reversed by encoding them into one number.

When an axis is reversed, what happens with its axis origin and
sampling parameters? This behavior is controlled by \texttt{opt=}. In
our example,
\begin{verbatim}
bash$ < test.rsf sfget n1 o1 d1
n1=5
o1=0
d1=1
bash$ < test.rsf sfreverse which=1 | sfget o1 d1
o1=4
d1=-1
\end{verbatim}
The default behavior (equivalent to \texttt{opt=y}) puts the origin
\texttt{o1} at the end of the axis and reverses the sampling parameter
\texttt{d1}.  Using \texttt{opt=n} preserves the sampling but reverses
the origin.
\begin{verbatim}
bash$ < test.rsf sfreverse which=1 opt=n | sfget o1 d1
o1=-4
d1=1
\end{verbatim}
Using \texttt{opt=i} preserves both the sampling and the origin while
reversing the axis.
\begin{verbatim}
bash$ < test.rsf sfreverse which=1 opt=i | sfget o1 d1
o1=0
d1=1
\end{verbatim}
One of the three possible behaviors may be desirable depending on the
application.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfrm}
  }}

\texttt{sfrm} is a program for removing RSF files. Its arguments mimic
the arguments of the standard Unix \texttt{rm} utility: \texttt{-v}
for verbosity, \texttt{-i} for interactive inquiry, \texttt{-f} for
force removal of suspicious files. Unlike the Unix \texttt{rm},
\texttt{sfrm} removes both the RSF header files and the binary files
that the headers point to. 

Example:
\begin{verbatim}
bash$ sfspike n1=10 > spike.rsf datapath=./
bash$ sfget in < spike.rsf
in=./spike.rsf@
bash$ ls spike*
spike.rsf  spike.rsf@
bash$ sfrm -v spike.rsf
sfrm: sf_rm: Removing header spike.rsf
sfrm: sf_rm: Removing data ./spike.rsf@
bash$ ls spike*
ls: No match.
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfrotate}
  }}

\inputdir{XFig}

\texttt{sfrotate} modifies the input dataset by splitting it into
parts and putting the parts back in a different order. Here is a quick example.
\begin{verbatim}
bash$ sfmath n1=5 d1=1 n2=3 d2=1 output=x1+x2 > test.rsf
bash$ < test.rsf sfdisfil
   0:             0            1            2            3            4
   5:             1            2            3            4            5
  10:             2            3            4            5            6
\end{verbatim}
Rotating the first axis by putting the last two columns in front:
\begin{verbatim}
bash$ < test.rsf sfrotate rot1=2 | sfdisfil
   0:             3            4            0            1            2
   5:             4            5            1            2            3
  10:             5            6            2            3            4
\end{verbatim}
Rotating the second axis by putting the last row in front:
\begin{verbatim}
bash$ < test.rsf sfrotate rot2=1 | sfdisfil
   0:             2            3            4            5            6
   5:             0            1            2            3            4
  10:             1            2            3            4            5
\end{verbatim}
Rotating both the first and the second axis:
\begin{verbatim}
bash$ < test.rsf sfrotate rot1=3 rot2=1 | sfdisfil
   0:             4            5            6            2            3
   5:             2            3            4            0            1
  10:             3            4            5            1            2
\end{verbatim}
The transformation is shown schematically in Figure~\ref{fig:rotate}.

\plot{rotate}{width=\textwidth}{Schematic transformation of data with \texttt{sfrotate}.}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfrtoc}
  }}

The input to \texttt{sfrtoc} can be any \texttt{type=float} dataset:
\begin{verbatim}
bash$ sfspike n1=10 n2=20 n3=30 >real.rsf
bash$ sfin real.rsf
real.rsf:
    in="/var/tmp/real.rsf@"
    esize=4 type=float form=native 
    n1=10          d1=0.004       o1=0          label1="Time" unit1="s" 
    n2=20          d2=0.1         o2=0          label2="Distance" unit2="km" 
    n3=30          d3=0.1         o3=0          label3="Distance" unit3="km" 
        6000 elements 24000 bytes
\end{verbatim}
The output dataset will have \texttt{type=complex}, and its binary will be
twice the size of the input:
\begin{verbatim}
bash$ <real.rsf sfrtoc >complex.rsf
bash$ sfin complex.rsf 
complex.rsf:
    in="/var/tmp/complex.rsf@"
    esize=8 type=complex form=native 
    n1=10          d1=0.004       o1=0          label1="Time" unit1="s" 
    n2=20          d2=0.1         o2=0          label2="Distance" unit2="km" 
    n3=30          d3=0.1         o3=0          label3="Distance" unit3="km" 
        6000 elements 48000 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfscale}
  }}

\texttt{sfscale} scales the input dataset by a factor. Here
are some simple examples. First, let us create a test dataset.
\begin{verbatim}
bash$ sfmath n1=5 n2=3 o1=1 o2=1 output="x1*x2" > test.rsf
bash$ < test.rsf sfdisfil   
   0:             1            2            3            4            5
   5:             2            4            6            8           10
  10:             3            6            9           12           15
\end{verbatim}
Scale every data point by 2:
\begin{verbatim}
bash$ < test.rsf sfscale dscale=2 | sfdisfil
   0:             2            4            6            8           10
   5:             4            8           12           16           20
  10:             6           12           18           24           30
\end{verbatim}
Divide every trace by its maximum value:
\begin{verbatim}
bash$ < test.rsf sfscale axis=1 | sfdisfil
   0:           0.2          0.4          0.6          0.8            1
   5:           0.2          0.4          0.6          0.8            1
  10:           0.2          0.4          0.6          0.8            1
\end{verbatim}
Divide by the maximum value in the whole 2-D dataset:
\begin{verbatim}
bash$ < test.rsf sfscale axis=2 | sfdisfil
   0:       0.06667       0.1333          0.2       0.2667       0.3333
   5:        0.1333       0.2667          0.4       0.5333       0.6667
  10:           0.2          0.4          0.6          0.8            1
\end{verbatim}
The \texttt{rscale=} parameter is synonymous to \texttt{dscale=} except
when it is equal to zero. With \texttt{sfscale dscale=0}, the dataset gets
multiplied by zero. If using \texttt{rscale=0}, the other parameters are
used to define scaling.  Thus, \texttt{sfscale rscale=0 axis=1} is
equivalent to \texttt{sfscale axis=1}, and \texttt{sfscale rscale=0}
is equivalent to \texttt{sfscale dscale=1}.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfspike}
  }}

\texttt{sfspike} takes no input and generates an output with
``spikes''. It is an easy way to create data. Here is an example:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 k1=4 k2=1 | sfdisfil
   0:             0            0            0            1            0
   5:             0            0            0            0            0
  10:             0            0            0            0            0
\end{verbatim}
The spike location is specified by parameters \texttt{k1=4} and
\texttt{k2=1}. Note that the locations are numbered starting from 1. 
If one of the parameters is omitted or given the value of zero, the 
spike in the corresponding direction becomes a plane:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 k1=4 | sfdisfil   
   0:             0            0            0            1            0
   5:             0            0            0            1            0
  10:             0            0            0            1            0

\end{verbatim}
If no spike parameters are given, the whole dataset is filled with ones:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 | sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
\end{verbatim}

To create several spikes, use the \texttt{nsp=} parameter and give a comma-separated list of values to \texttt{k\#=} arguments:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 nsp=3 k1=1,3,4 k2=1,2,3 | sfdisfil
   0:             1            0            0            0            0
   5:             0            0            1            0            0
  10:             0            0            0            1            0
\end{verbatim}
If the number of values in the list is smaller than \texttt{nsp}, the
last value gets repeated, and the spikes add on top of each other,
creating larger amplitudes:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 nsp=3 k1=1,3 k2=1,2 | sfdisfil
   0:             1            0            0            0            0
   5:             0            0            2            0            0
  10:             0            0            0            0            0
\end{verbatim}
The magnitude of the spikes can be controlled explicitly with the
\texttt{mag=} parameter:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 nsp=3 k1=1,3,4 k2=1,2,3 mag=1,4,2 | sfdisfil
   0:             1            0            0            0            0
   5:             0            0            4            0            0
  10:             0            0            0            2            0
\end{verbatim}

You can create boxes instead of spikes by using \texttt{l\#=}
parameters:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 k1=2 l1=4 k2=2 mag=8 | sfdisfil
   0:             0            0            0            0            0
   5:             0            8            8            8            0
  10:             0            0            0            0            0
\end{verbatim}
In this case, \texttt{k1=2} specifies the box start, and \texttt{l1=4}
specifies the box end.

Finally, multi-dimensional planes can be given an inclination by using \texttt{p\#=} parameters:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 k1=2 p2=1 | sfdisfil
   0:             0            1            0            0            0
   5:             0            0            1            0            0
  10:             0            0            0            1            0
\end{verbatim}
When the inclination value is not integer, simple linear interpolation is used:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 k1=2 p2=0.7 | sfdisfil
   0:             0            1            0            0            0
   5:             0          0.3          0.7            0            0
  10:             0            0          0.6          0.4            0
\end{verbatim}

\texttt{sfspike} supplies default dimensions and labels to all axis:
\begin{verbatim}
bash$ sfspike n1=5 n2=3 n3=4 > spike.rsf
bash$ sfin spike.rsf
spike.rsf:
    in="/var/tmp/spike.rsf@"
    esize=4 type=float form=native 
    n1=5           d1=0.004       o1=0          label1="Time" unit1="s" 
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km" 
    n3=4           d3=0.1         o3=0          label3="Distance" unit3="km" 
	60 elements 240 bytes
\end{verbatim}
As you can see, the first axis is assumed to be time, with sampling of
$0.004$ seconds. All other axes are assumed to be distance, with
sampling of $0.1$ kilometers. All these parameters can be changed on
the command line.
\begin{verbatim}
bash$ sfspike n1=5 n2=3 n3=4 label3=Offset unit3=ft d3=20 > spike.rsf
bash$ sfin spike.rsf
spike.rsf:
    in="/var/tmp/spike.rsf@"
    esize=4 type=float form=native 
    n1=5           d1=0.004       o1=0          label1="Time" unit1="s" 
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km" 
    n3=4           d3=20          o3=0          label3="Offset" unit3="ft" 
	60 elements 240 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfspray}
  }}

\texttt{sfspray} extends the input hypercube by replicating the data
in one of the dimensions. The output dataset acquires one additional
dimension. Here is an example:

Start with a 2-D dataset
\begin{verbatim}
bash$ sfmath n1=5 n2=2 output=x1+x2 > test.rsf
bash$ sfin test.rsf
test.rsf:
    in="/var/tmp/test.rsf@"
    esize=4 type=float form=native 
    n1=5           d1=1           o1=0          
    n2=2           d2=1           o2=0          
        10 elements 40 bytes
bash$ < test.rsf sfdisfil
   0:             0            1            2            3            4
   5:             1            2            3            4            5
\end{verbatim}

Extend the data in the second dimension
\begin{verbatim}
bash$ < test.rsf sfspray axis=2 n=3 > test2.rsf
bash$ sfin test2.rsf
test2.rsf:
    in="/var/tmp/test2.rsf@"
    esize=4 type=float form=native 
    n1=5           d1=1           o1=0          
    n2=3           d2=1           o2=0          
    n3=2           d3=1           o3=0          
        30 elements 120 bytes
bash$ < test2.rsf sfdisfil
   0:             0            1            2            3            4
   5:             0            1            2            3            4
  10:             0            1            2            3            4
  15:             1            2            3            4            5
  20:             1            2            3            4            5
  25:             1            2            3            4            5
\end{verbatim}
The output is three-dimensional, with traces from the original
data duplicated along the second axis.

Extend the data in the third dimension
\begin{verbatim}
bash$ < test.rsf sfspray axis=3 n=2 > test3.rsf
bash$ sfin test3.rsf
test3.rsf:
    in="/var/tmp/test3.rsf@"
    esize=4 type=float form=native 
    n1=5           d1=1           o1=0          
    n2=2           d2=1           o2=0          
    n3=2           d3=?           o3=?          
        20 elements 80 bytes
bash$ < test3.rsf sfdisfil
   0:             0            1            2            3            4
   5:             1            2            3            4            5
  10:             0            1            2            3            4
  15:             1            2            3            4            5
\end{verbatim}
The output is also three-dimensional, with the original data replicated
along the third axis.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfstack}
  }}

While \texttt{sfspray} adds a dimension to a hypercube,
\texttt{sfstack} effectively removes one of the dimensions by stacking
over it. Here are some examples:
\begin{verbatim}
bash$ sfmath n1=5 n2=3 output=x1+x2 > test.rsf
bash$ < test.rsf sfdisfil
   0:             0            1            2            3            4
   5:             1            2            3            4            5
  10:             2            3            4            5            6
bash$ < test.rsf sfstack axis=2 | sfdisfil
   0:           1.5            2            3            4            5
bash$ < test.rsf sfstack axis=1 | sfdisfil
   0:           2.5            3            4
\end{verbatim}
Why is the first value not 1 (in the first case) or 2 (in the second
case)? By default, \texttt{sfstack} normalizes the stack by the fold
(the number of non-zero entries). To avoid normalization, use
\texttt{norm=n}, as follows:
\begin{verbatim}
bash$ < test.rsf sfstack norm=n | sfdisfil 
   0:             3            6            9           12           15
\end{verbatim}
\texttt{sfstack} can also compute root-mean-square values as 
well as minimum and maximum values.
\begin{verbatim}
bash$ < test.rsf sfstack rms=y | sfdisfil
   0:         1.581         2.16        3.109        4.082        5.066
bash$ < test.rsf sfstack min=y | sfdisfil
   0:             0            1            2            3            4
bash$ < test.rsf sfstack axis=1 max=y | sfdisfil 
   0:             4            5            6
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sftransp}
  }}

The \texttt{sftransp} program transposes the input hypercube
exchanging the two axes specified by the \texttt{plane=} parameter. 
\begin{verbatim}
bash$ sfspike n1=10 n2=20 n3=30 > orig123.rsf
bash$ sfin orig123.rsf 
orig123.rsf:
    in="/var/tmp/orig123.rsf@"
    esize=4 type=float form=native 
    n1=10          d1=0.004       o1=0          label1="Time" unit1="s" 
    n2=20          d2=0.1         o2=0          label2="Distance" unit2="km" 
    n3=30          d3=0.1         o3=0          label3="Distance" unit3="km" 
        6000 elements 24000 bytes
bash$ <orig123.rsf sftransp plane=23 >out132.rsf
bash$ sfin out132.rsf 
out132.rsf:
    in="/var/tmp/out132.rsf@"
    esize=4 type=float form=native 
    n1=10          d1=0.004       o1=0          label1="Time" unit1="s" 
    n2=30          d2=0.1         o2=0          label2="Distance" unit2="km" 
    n3=20          d3=0.1         o3=0          label3="Distance" unit3="km" 
        6000 elements 24000 bytes
bash$ <orig123.rsf sftransp plane=13 >out321.rsf
bash$ sfin out321.rsf 
out321.rsf:
    in="/var/tmp/out132.rsf@"
    esize=4 type=float form=native 
    n1=30          d1=0.1         o1=0          label1="Distance" unit1="km" 
    n2=20          d2=0.1         o2=0          label2="Distance" unit2="km" 
    n3=10          d3=0.004       o3=0          label3="Time" unit3="s" 
        6000 elements 24000 bytes
\end{verbatim}
\texttt{sftransp} tries to fit the dataset in memory to transpose it
there but, if not enough memory is available, it performs a slower
transpose out of core using disk operations. You can control the
amount of available memory using the \texttt{memsize=} parameter or
the \texttt{RSFMEMSIZE} environmental variable.


\noindent\doublebox{\parbox{\textwidth}{
    \input{sfwindow}
  }}

\texttt{sfwindow} is used to window a portion of the dataset. Here is
a quick example: Start by creating some data.
\begin{verbatim}
bash$ sfmath n1=5 n2=3 o1=1 o2=1 output="x1*x2" > test.rsf
bash$ < test.rsf sfdisfil
   0:             1            2            3            4            5
   5:             2            4            6            8           10
  10:             3            6            9           12           15
\end{verbatim}
Now window the first two rows:
\begin{verbatim}
bash$ < test.rsf sfwindow n2=2 | sfdisfil
   0:             1            2            3            4            5
   5:             2            4            6            8           10
\end{verbatim}
Window the first three columns:
\begin{verbatim}
bash$ < test.rsf sfwindow n1=3 | sfdisfil
   0:             1            2            3            2            4
   5:             6            3            6            9
\end{verbatim}
Window the middle row:
\begin{verbatim}
bash$ < test.rsf sfwindow f2=1 n2=1 | sfdisfil
   0:             2            4            6            8           10
\end{verbatim}
You can interpret the \texttt{f\#} and \texttt{n\#} parameters as
meaning "skip that many rows/columns" and "select that many
rows/columns" correspondingly. Window the middle point in the dataset:
\begin{verbatim}
bash$ < test.rsf sfwindow f1=2 n1=1 f2=1 n2=1 | sfdisfil
   0:             6
\end{verbatim}
Window every other column:
\begin{verbatim}
bash$ < test.rsf sfwindow j1=2 | sfdisfil
   0:             1            3            5            2            6
   5:            10            3            9           15
\end{verbatim}
Window every third column:
\begin{verbatim}
bash$ < test.rsf sfwindow j1=3 | sfdisfil
   0:             1            4            2            8            3
   5:            12
\end{verbatim}

Alternatively, \texttt{sfwindow} can use the minimum and maximum
parameters to select a window. In the following example, we are
creating a dataset with \texttt{sfspike} and then windowing a portion of it
between 1 and 2 seconds in time and sampled at 8 miliseconds.
\begin{verbatim}
bash$ sfspike n1=1000 n2=10 > spike.rsf         
bash$ sfin spike.rsf
spike.rsf:
    in="/var/tmp/spike.rsf@"
    esize=4 type=float form=native 
    n1=1000        d1=0.004       o1=0          label1="Time" unit1="s" 
    n2=10          d2=0.1         o2=0          label2="Distance" unit2="km" 
        10000 elements 40000 bytes
bash$ < spike.rsf sfwindow min1=1 max1=2 d1=0.008 > window.rsf
bash$ sfin window.rsf
window.rsf:
    in="/var/tmp/window.rsf@"
    esize=4 type=float form=native 
    n1=126         d1=0.008       o1=1          label1="Time" unit1="s" 
    n2=10          d2=0.1         o2=0          label2="Distance" unit2="km" 
        1260 elements 5040 bytes
\end{verbatim}

By default, \texttt{sfwindow} ``squeezes'' the hypercube dimensions
that are equal to one toward the end of the dataset. Here is an
example of taking a time slice:
\begin{verbatim}
bash$ < spike.rsf sfwindow n1=1 min1=1 > slice.rsf
bash$ sfin slice.rsf 
slice.rsf:
    in="/var/tmp/slice.rsf@"
    esize=4 type=float form=native 
    n1=10          d1=0.1         o1=0          label1="Distance" unit1="km" 
    n2=1           d2=0.004       o2=1          label2="Time" unit2="s" 
        10 elements 40 bytes
\end{verbatim}
You can change this behavior by specifying \texttt{squeeze=n}.
\begin{verbatim}
bash$ < spike.rsf sfwindow n1=1 min1=1 squeeze=n > slice.rsf
bash$ sfin slice.rsf 
slice.rsf:
    in="/var/tmp/slice.rsf@"
    esize=4 type=float form=native 
    n1=1           d1=0.004       o1=1          label1="Time" unit1="s" 
    n2=10          d2=0.1         o2=0          label2="Distance" unit2="km" 
        10 elements 40 bytes
\end{verbatim}


\bibliographystyle{seg}
\bibliography{SEG,shell}
